# Types of Operating Systems

An **Operating System (OS)** manages computer hardware and software resources and provides services for computer programs.  
Different systems have different requirements, so operating systems are classified into various types based on their functionality and usage.

![Types of OS](images/types_of_operating_system.png)

---

## 1. Batch Operating System

### Overview

- Designed to **execute batches of jobs** with *no direct interaction* between user and computer during execution.

- Introduced in the 1950s–60s on mainframes to automate repetitive tasks like payroll or scientific computations.

### Working

1. **Job Preparation:** Users submit jobs (program + data) to an operator.

2. **Batch Formation:** Operator groups similar jobs into batches (e.g., all Fortran jobs).

3. **Execution:** OS runs each batch sequentially; output is produced after all jobs in the batch finish.

### Key Characteristics

- **Sequential Execution:** Jobs processed one after another.

- **Offline User Interaction:** User cannot modify the job mid-execution.

- **Spooling:** Input/output data is buffered on disk to keep CPU busy.

### Advantages

- **High Throughput:** Suitable for large, repetitive jobs.

- **Efficient CPU Utilization:** CPU rarely idle because jobs are queued in advance.

### Disadvantages

- **Long Turnaround Time:** Users wait until the batch completes to see results.

- **Difficult Debugging:** Errors found only after full batch execution.

- **No Interactivity:** Not suited for tasks needing immediate user input.

### Real-World Examples

- Early IBM OS/360, DOS batch systems.

---

## 2. Multi-Programming Operating System

### Overview

- Allows **multiple programs** to be loaded in memory and executed by **sharing CPU time**.

- The CPU switches to another job when the current job waits for I/O.

### How It Works

- **Memory Partitioning:** Multiple programs reside simultaneously in RAM.

- **Context Switching:** CPU rapidly switches between jobs, giving the illusion of parallelism.

### Key Features

- **Maximizes CPU Utilization:** CPU never waits idle for I/O.

- **Job Prioritization:** Higher priority jobs can preempt lower ones.

### Advantages

- Better hardware utilization than batch OS.

- Shorter average waiting time for jobs.

### Disadvantages

- **Complex Memory Management:** Requires sophisticated algorithms for allocation and protection.

- **Potential Deadlocks:** Multiple processes competing for resources.

### Examples

- UNIX (early versions), OS/2.

---

## 3. Time-Sharing (Multi-Processing) Operating System

### Overview

- Extension of multiprogramming where **multiple users or processes interact with the system simultaneously**.

- Achieved through **time slicing**—CPU time is divided into small units and allocated to each active process.

### Key Characteristics

- **Quick Response:** Each user gets a dedicated slice of CPU time, giving an interactive experience.

- **Preemptive Scheduling:** Processes can be interrupted to ensure fairness.

- **Multi-User Support:** Multiple terminals can access the same system.

### Advantages

- Excellent for **interactive applications** like text editing or programming.

- **Efficient Resource Sharing:** Hardware resources shared by many users.

### Disadvantages
- **Security Concerns:** Multiple users require strong isolation.

- **Overhead:** Context switching adds CPU overhead.

### Examples

- Modern UNIX/Linux, macOS, Windows.

---

## 4. Real-Time Operating System (RTOS)

### Overview

- Guarantees a **deterministic response** to external events within a strict deadline.

- Used when timing is as critical as correctness.

### Types

- **Hard RTOS:** Missing a deadline is catastrophic (e.g., flight control, pacemakers).

- **Soft RTOS:** Occasional deadline misses are tolerable (e.g., video streaming, VoIP).

### Core Features

- **Predictable Scheduling:** Priority-based or rate-monotonic algorithms.

- **Minimal Latency:** Interrupts handled immediately.

- **Resource Reservation:** CPU and memory allocated for critical tasks.

### Advantages

- Reliable, deterministic performance.

- Essential for life-critical and industrial systems.

### Disadvantages

- Expensive to design and maintain.

- Limited flexibility for non-critical tasks.

### Examples
- VxWorks, QNX, RTLinux, FreeRTOS.

---

## 5. Distributed Operating System

### Overview

- Manages a **collection of independent computers** and presents them to the user as a single coherent system.

- Enables **resource sharing, load balancing, and fault tolerance**.

### Key Characteristics

- **Transparency:** Users see a single system, unaware of the underlying nodes.

- **Resource Sharing:** CPU cycles, storage, and peripherals shared across the network.

- **Fault Tolerance:** If one node fails, others continue service.

### Advantages

- High performance through parallel processing.

- Scalability: Easy to add more nodes.

### Disadvantages

- Complex design and communication protocols.

- Network dependency—failure in network can reduce performance.

### Examples

- Amoeba, LOCUS, Google’s internal cluster OS (Borg concepts).

---

## 6. Network Operating System (NOS)

### Overview

- Specialized OS that runs on **servers** to enable **file sharing, user management, and communication** over a network.

### Key Features

- Centralized control of resources.

- Built-in security, user authentication, and data backup.

- Supports client–server architecture.

### Advantages

- Easy maintenance and upgrades.

- Robust security and centralized administration.

### Disadvantages

- Requires dedicated hardware (server).

- Server failures can disrupt the whole network.

### Examples
- Windows Server, Novell NetWare, UNIX/Linux server editions.

---

## 7. Mobile Operating System

- **Definition:** Designed for smartphones, tablets, and other handheld devices.

- **Features:** Touch interface, power optimization, app ecosystems.

- **Examples:** Android, iOS, Windows Phone.

---

## 8. Embedded Operating System

- **Definition:** Built for specialized devices with limited hardware resources.

- **Usage:** IoT devices, home appliances, medical equipment.

- **Examples:** Embedded Linux, FreeRTOS, Windows IoT.

---

## 9. Single-User, Single-Tasking OS

- **Definition:** One user can run only one task at a time.

- **Examples:** MS-DOS, early Palm OS.

---

## 10. Single-User, Multi-Tasking OS

- **Definition:** One user can run multiple applications simultaneously.

- **Examples:** Modern Windows, macOS.

---

## Comparison Table

| Type                    | Multi-User | Real-Time | Example OS           |
|-------------------------|-----------|----------|----------------------|
| **Batch**                  | No        | No       | IBM OS/360           |
| **Multi-Programming**      | No        | No       | UNIX, Linux          |
| **Time-Sharing**           | Yes       | No       | Windows, macOS       |
| **Real-Time**             | Sometimes | Yes      | VxWorks, QNX         |
| **Distributed**           | Yes       | Varies   | Amoeba, Plan 9       |
| **Network**               | Yes       | No       | Windows Server       |
| **Mobile**                | Yes       | Sometimes| Android, iOS         |
| **Embedded**              | No        | Often    | FreeRTOS, Embedded Linux |

---

## Summary

- **Batch OS** → Executes jobs in groups without interaction.  

- **Multi-Programming/Tasking** → Runs several processes at once.  

- **Real-Time OS** → Guarantees immediate response.  

- **Distributed OS** → Uses multiple machines as one system.  

- **Network OS** → Manages resources across a network.  

- **Mobile & Embedded OS** → Specialized for portable and dedicated devices.

These types are often combined in modern systems (e.g., Android is multi-tasking, network-enabled, and mobile).
